using UnityEngine;

public class RayTracer : MonoBehaviour
{
    // Weather or not to render in real time
    public bool RealTime = false;

    // How much of our screen resolution we render at
    public int RenderResolution = 1;

    private Texture2D renderTexture;
    private Light[] lights;

    // Collision Mask
    private LayerMask collisionMask = 1 << 31;

    // Create render texture with screen size with resolution
    public void Awake()
    {
        renderTexture = new Texture2D(Screen.width * RenderResolution, Screen.height * RenderResolution);
    }

    // Do one raytrace when we start playing
    public void Start()
    {
        GenerateColliders();

        if (!RealTime)
        {
            RayTrace();
            //RTRenderer.SaveTextureToFile(renderTexture, "lolies.png");
        }
    }

    // Real Time Rendering
    public void Update()
    {
        if (RealTime)
        {
            RayTrace();
        }
    }

    // Draw the render
    public void OnGUI()
    {
        //Draw texture to screen with origin 0,0, width and height of the screen, and the texture generated by the RT
        GUI.DrawTexture(new Rect(0, 0, Screen.width, Screen.height), renderTexture);
    }

    // The function that renders the entire scene to a texture
    public void RayTrace()
    {
        // Gather all lights
        lights = FindObjectsOfType<Light>();

        // For each pixel
        for (int x = 0; x < renderTexture.width; x++)
        {
            for (int y = 0; y < renderTexture.height; y++)
            {
                // Now that we have an x/y value for each pixel, we need to make that into a 3d ray
                // according to the camera we are attached to

                // Z should be 0 as it is the distance from the camera
                Ray ray = Camera.main.ScreenPointToRay(new Vector3(x / RenderResolution, y / RenderResolution, 0));

                // Now lets call a function with this ray and apply its return value to the pixel we are on
                // We will define this function afterwards

                // Sets the pixel at coordinates x,y, according to the return of TraceRay
                renderTexture.SetPixel(x, y, TraceRay(ray));
            }
        }

        // When all pixels have been rendered, apply the texture
        renderTexture.Apply();
    }

    // Trace a Ray for a single point
    public Color TraceRay(Ray ray)
    {
        // The color we change throughout the function
        // Set color to black if we don't hit anything
        Color returnColor = Color.black;

        // Hit information
        RaycastHit hit;

        // Cast physics ray, on hit, do If statement
        // Cast ray, return hit info, cast to infinity, and only collide with layers on the collisionMask
        if (Physics.Raycast(ray, out hit, Mathf.Infinity, collisionMask))
        {
            // The material of the object we hit
            Material mat;

            // Get the material of the object hit
            mat = hit.collider.transform.parent.GetComponent<Renderer>().material;

            // If the material has a texture
            if (mat.mainTexture)
            {
                // Return the color of the pixel at the pixel coordinate of the hit, according to the UV map of the texture
                returnColor += (mat.mainTexture as Texture2D).GetPixelBilinear(hit.textureCoord.x, hit.textureCoord.y);
            }
            else
            {
                // Return the material color (Solid color)
                returnColor += mat.color;
            }

            // Calculate the illumination of the color, at the hit point
            // The more normal the light, the brighter the return color
            returnColor *= TraceLight(hit.point + hit.normal * 0.0001f, hit.normal);
        }

        // The color of this pixel
        return returnColor;
    }

    // Trace a single point for all lights, iterates through all lights
    public Color TraceLight(Vector3 pos, Vector3 normal)
    {
        // Set starting light to that of the render settings
        Color returnColor = RenderSettings.ambientLight;

        // We loop through all the lights and perform a light addition with each
        foreach (Light light in lights)
        {
            if (light.enabled)
            {
                // Add the light that this light source casts to the color of this point
                returnColor += LightTrace(light, pos, normal);
            }
        }
        return returnColor;
    }

    // Trace a single point for a single light
    public Color LightTrace(Light light, Vector3 pos, Vector3 normal)
    {
        float dot;

        // Trace the directional light
        if (light.type == LightType.Directional)
        {
            // Calculate the dot product
            // Negative to align vector directions
            dot = Vector3.Dot(-light.transform.forward, normal);

            // Only perform lighting calculations if the dot is more than 0
            if (dot > 0)
            {
                //If light source is blocked by a collidable object with collisionMask, then return black
                //Cast ray between the point on the collider surface and the lightsource
                if (Physics.Raycast(pos, -light.transform.forward, Mathf.Infinity, collisionMask))
                {
                    return Color.black;
                }

                // Combine the color and intensity inherent to the light, multiplied by the dot of the light and the normal (illumination)
                return light.color * light.intensity * dot;
            }

            // If no light detected
            return Color.black;
        }

        // All non-single directional lights
        else
        {
            // Get the direction of the light source from the point
            Vector3 direction = (light.transform.position - pos).normalized;

            // Calculate the dot between the direction and the normal of the point
            dot = Vector3.Dot(normal, direction);

            // Calculate the scalar distance between the lightsource and the point
            float distance = Vector3.Distance(pos, light.transform.position);

            // If the distance is within the light range, and the dot is greater than 0
            if (distance < light.range && dot > 0)
            {
                // Check for a point light source
                if (light.type == LightType.Point)
                {
                    // If object is obscuring light, return black
                    if (Physics.Raycast(pos, direction, distance, collisionMask))
                    {
                        return Color.black;
                    }

                    //Otherwise, return the inherent light color and intensity multiplied by the dot
                    //  .. then multiply a dimming effect accoridng to the distance from the light
                    return light.color * light.intensity * dot * (1 - distance / light.range);
                }

                // Check for spot light source
                else if (light.type == LightType.Spot)
                {
                    // Get dot between the forward face of the spot light and the direction of the light to the point
                    float dot2 = Vector3.Dot(-light.transform.forward, direction);

                    // Check is light is illuminating point (Is point within the possible illumination area)
                    if (dot2 > (1 - light.spotAngle / 180))
                    {
                        //Check for obscuring object
                        if (Physics.Raycast(pos, direction, distance, collisionMask))
                        {
                            return Color.black;
                        }

                        // Return the inherent light color times the intensity, then multiplied by the dot between
                        // .. the direction and the normal of the point, multiplied times the percentage of range for illuminance
                        // .. then multiplied by the intensity of the light based on the relative angle to the light
                        return light.color * light.intensity * dot * (1 - distance / light.range) * (dot2 / (1 - light.spotAngle / 180));
                    }
                }
            }

            //Else return black
            return Color.black;
        }
    }

    // Example in GenerateColliders method
    public void GenerateColliders()
    {
        // Loop through all mesh filters
        foreach (MeshFilter mf in FindObjectsOfType<MeshFilter>())
        {
            // If the meshfilter has a mesh renderer
            // Create mesh colliders on each object to be detected by the ray tracing
            
            // Can cause problems with planes, need to removed convex for planes
            if (mf.GetComponent<MeshRenderer>())
            {
                // Create a new object we will use for rendering
                GameObject tmpGO = new GameObject("RTRMeshRenderer");
                
                // Add a MeshCollider and set it as convex
                MeshCollider meshCollider = tmpGO.AddComponent<MeshCollider>();
                meshCollider.sharedMesh = mf.mesh;
                meshCollider.convex = true; // Enable convex

                tmpGO.transform.parent = mf.transform;
                tmpGO.transform.localPosition = Vector3.zero;
                tmpGO.transform.localScale = Vector3.one;
                tmpGO.transform.localRotation = Quaternion.identity;

                // Set collider as trigger
                tmpGO.GetComponent<Collider>().isTrigger = true;
                tmpGO.layer = 31;
            }
        }
    }
}
